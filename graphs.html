<!doctype html>
<html>
<head>
	<title>Informatica Component Library</title>
	<link rel="stylesheet" type="text/css" href="" />
</head>
<body>
	<canvas id="mycanvas">
		I am fallback content, incase canvas doesn't render.
	</canvas>
	
<script type="text/javascript">
(function() {
	var canvas = document.getElementById("mycanvas");
	canvas.width = window.innerWidth - 20;
	canvas.height = window.innerHeight - 20;
	if(canvas.getContext) {
		var context = canvas.getContext('2d'),
			cwidth = canvas.width,
			cheight = canvas.height
			centerX = cwidth/2,
			centerY = cheight/2
			maxX = 20,
			minX = -20,
			maxY = maxX * (cheight / cwidth),
			minY = minX * (cheight / cwidth),
			xtick = 1,
			ytick = 1,
			tickHeight = 2
		;
		
		// for a given logical x, return physical x
		function X(x) { return (x - minX) / (maxX - minX) * cwidth; }
		// for a given logical y, return physical y
		function Y(y) { return cheight - ((y - minY) / (maxY - minY) * cheight); }

		context.clearRect(0, 0, cwidth, cheight);


		function drawAxes() {
			context.lineWidth = 2;

			// +Y
			context.beginPath();
			context.moveTo(X(0), Y(0));
			context.lineTo(X(0), Y(maxY));
			context.stroke();

			// -Y
			context.beginPath();
			context.moveTo(X(0), Y(0));
			context.lineTo(X(0), Y(minY));
			context.stroke();

			// +X
			context.beginPath();
			context.moveTo(X(0), Y(0));
			context.lineTo(X(maxX), Y(0));
			context.stroke();

			// -X
			context.beginPath();
			context.moveTo(X(0), Y(0));
			context.lineTo(X(minX), Y(0));
			context.stroke();

			// +X ticks
			for(var i = 1; i < maxX; i++) {
				context.beginPath();
				context.moveTo(X(i), Y(0)-tickHeight);
				context.lineTo(X(i), Y(0)+tickHeight);
				context.stroke();
			}

			// -X ticks
			for(var i = 1; i > minX; i--) {
				context.beginPath();
				context.moveTo(X(i), Y(0)-tickHeight);
				context.lineTo(X(i), Y(0)+tickHeight);
				context.stroke();
			}

			// +Y ticks
			for(var i = 1; i < maxY; i++) {
				context.beginPath();
				context.moveTo(X(0)-tickHeight, Y(i));
				context.lineTo(X(0)+tickHeight, Y(i));
				context.stroke();
			}

			// -Y ticks
			for(var i = 1; i > minY; i--) {
				context.beginPath();
				context.moveTo(X(0)-tickHeight, Y(i));
				context.lineTo(X(0)+tickHeight, Y(i));
				context.stroke();
			}
		}


		function renderGraph(f) {
			var xStep = (maxX - minX) / cwidth,
				moveTo = true;
			context.lineWidth = 1;
			for(var x = minX; x <= maxX; x += xStep) {
				var y = f(x);
				if(moveTo) {
					context.moveTo(X(x), Y(y));
					moveTo = false;
				}
				else
					context.lineTo(X(x), Y(y));
			}
			// context.lineCap = "square";
			var lineargradient = context.createLinearGradient(0,0,800,800);
			lineargradient.addColorStop(0, 'blue');
			lineargradient.addColorStop(0.7, 'green');
			lineargradient.addColorStop(0.8, 'orange');
			lineargradient.addColorStop(0.9, 'steelblue');
			lineargradient.addColorStop(1, 'red');
			context.strokeStyle = lineargradient;
			context.stroke();
		}


		drawAxes();
		var F = function(x) {
			return Math.sin(x);
		}

		var G = function(y) {
			return Math.tan(y);
		}

		var circle = function(r) {
			// var r = r || 1;
			context.beginPath();
			for(var theta = 0; theta <= 100*Math.PI; theta+= 0.1) {
				context.lineTo(
		// X co-ordinate
					X(Math.tan(Math.sqrt(theta))*Math.cos(theta)),
		// Y co-ordinate
					Y(Math.tan(Math.sqrt(theta))*Math.sin(theta))
				);
			}
			context.lineWidth = 0.5;
			context.stroke();
		}

		renderGraph(F);
		// renderGraph(circle());
		// polygon(5);
		context.save();


		// to test saving and restoring
		context.globalAlpha = 1;
		function alternative() {
			for(var i = 100; i >= 1; i--) {
				if(i % 2 == 0) {
					context.fillStyle = "red";
				} else {
					context.fillStyle = "yellow";
				}
				context.fillRect(centerX - (i*20)/2, centerY - (i*20)/2, i*20, i*20);
			}
		}
// alternative();

// starting bakchod
		function target(c, gap) {
			gap = gap || 5;
			for(var x = 0; x <= c; x+= gap) {
				context.arc(c, c, x, 0, Math.PI*2);
			}
			context.stroke();
		}

		function polygon(sides) {
			sides = sides || 3;
			for(var x = 0; x <= Math.PI*2; x+= Math.PI*2/sides) {
				context.arc(300, 400, 100, x, x, true)
			}
				// context.arc(200, 200, 100, Math.PI/2, Math.PI/3*2, true);
			context.stroke();
		}

		function roundedRect(ctx,x,y,width,height,radius){
			ctx.beginPath();
			ctx.moveTo(x,y+radius);
			ctx.lineTo(x,y+height-radius);
			ctx.quadraticCurveTo(x,y+height,x+radius,y+height);
			ctx.lineTo(x+width-radius,y+height);
			ctx.quadraticCurveTo(x+width,y+height,x+width,y+height-radius);
			ctx.lineTo(x+width,y+radius);
			ctx.quadraticCurveTo(x+width,y,x+width-radius,y);
			ctx.lineTo(x+radius,y);
			ctx.quadraticCurveTo(x,y,x,y+radius);
			ctx.stroke();
		}

	} else {
		// alternative
	}

})();
</script>

</body>
</html>