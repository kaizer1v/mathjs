<!doctype html>
<html>
<head>
	<title>Informatica Component Library</title>
	<link rel="stylesheet" type="text/css" href="" />
</head>
<body>
	<canvas id="mycanvas" height="800" width="1000">
		I am fallback content, incase canvas doesn't render.
	</canvas>
	
<script type="text/javascript">
(function() {
	var canvas = document.getElementById("mycanvas");
	if(canvas.getContext) {
		var context = canvas.getContext('2d'),
			cwidth = canvas.width,
			cheight = canvas.height
			centerX = canvas.width/2,
			centerY = canvas.height/2
			maxX = 20,
			minX = -20,
			maxY = maxX * (cheight / cwidth),
			minY = minX * (cheight / cwidth),
			xtick = 1,
			ytick = 1,
			tickHeight = 2
		;
		
		// for a given logical x, return physical x
		function X(x) { return (x - minX) / (maxX - minX) * cwidth; }
		// for a given logical y, return physical y
		function Y(y) { return cheight - ((y - minY) / (maxY - minY) * cheight); }

		context.clearRect(0, 0, cwidth, cheight);


		function drawAxes() {
			context.lineWidth = 2;

			// +Y
			context.beginPath();
			context.moveTo(X(0), Y(0));
			context.lineTo(X(0), Y(maxY));
			context.stroke();

			// -Y
			context.beginPath();
			context.moveTo(X(0), Y(0));
			context.lineTo(X(0), Y(minY));
			context.stroke();

			// +X
			context.beginPath();
			context.moveTo(X(0), Y(0));
			context.lineTo(X(maxX), Y(0));
			context.stroke();

			// -X
			context.beginPath();
			context.moveTo(X(0), Y(0));
			context.lineTo(X(minX), Y(0));
			context.stroke();

			// +X ticks
			for(var i = 1; i < maxX; i++) {
				context.beginPath();
				context.moveTo(X(i), Y(0)-tickHeight);
				context.lineTo(X(i), Y(0)+tickHeight);
				context.stroke();
			}

			// -X ticks
			for(var i = 1; i > minX; i--) {
				context.beginPath();
				context.moveTo(X(i), Y(0)-tickHeight);
				context.lineTo(X(i), Y(0)+tickHeight);
				context.stroke();
			}

			// +Y ticks
			for(var i = 1; i < maxY; i++) {
				context.beginPath();
				context.moveTo(X(0)-tickHeight, Y(i));
				context.lineTo(X(0)+tickHeight, Y(i));
				context.stroke();
			}

			// -Y ticks
			for(var i = 1; i > minY; i--) {
				context.beginPath();
				context.moveTo(X(0)-tickHeight, Y(i));
				context.lineTo(X(0)+tickHeight, Y(i));
				context.stroke();
			}
		}


		function renderGraph(f) {
			var xStep = (maxX - minX) / cwidth,
				moveTo = true;
			context.lineWidth = 1;
			for(var x = minX; x <= maxX; x += xStep) {
				var y = f(x);
				if(moveTo) {
					context.moveTo(X(x), Y(y));
					moveTo = false;
				}
				else
					context.lineTo(X(x), Y(y));
			}
			context.stroke();
		}


drawAxes();
var F = function(x) {
	return 10*Math.cos(x);
}
// renderGraph(F);

var G = function(y) {
	return Math.tan(y);
}

var circle = function(r) {
	var r = r || 1;
	context.beginPath();
	for(var theta = 0; theta <= 5*Math.PI; theta+= 0.1) {
		context.lineTo(
			X(theta*r*Math.tan(theta*Math.cos(theta))),				// X co-ordinate
			Y(theta*r*Math.sin(theta*Math.cos(theta)))				// Y co-ordinate
		);
	}
	context.stroke();
}
renderGraph(circle());
	

// starting bakchod
		function target(c, gap) {
			gap = gap || 5;
			for(var x = 0; x <= c; x+= gap) {
				context.arc(c, c, x, 0, Math.PI*2);
			}
			context.stroke();
		}

		function polygon(sides) {
			if(sides < 3) sides = 3;
			for(var x = 0; x <= Math.PI*2; x+= Math.PI*2/sides) {
				context.arc(200, 200, 100, x, x, true)
			}
				// context.arc(200, 200, 100, Math.PI/2, Math.PI/3*2, true);
			context.stroke();
		}

		function roundedRect(ctx,x,y,width,height,radius){
			ctx.beginPath();
			ctx.moveTo(x,y+radius);
			ctx.lineTo(x,y+height-radius);
			ctx.quadraticCurveTo(x,y+height,x+radius,y+height);
			ctx.lineTo(x+width-radius,y+height);
			ctx.quadraticCurveTo(x+width,y+height,x+width,y+height-radius);
			ctx.lineTo(x+width,y+radius);
			ctx.quadraticCurveTo(x+width,y,x+width-radius,y);
			ctx.lineTo(x+radius,y);
			ctx.quadraticCurveTo(x,y,x,y+radius);
			ctx.stroke();
		}

	} else {
		// alternative
	}

})();
</script>

</body>
</html>